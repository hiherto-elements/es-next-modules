<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">punycode/punycode.js | @hiherto-elements/punycode</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="minimal es6 punycode de- and encoder, forked from the &apos;original&apos; "><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@hiherto-elements/punycode"><meta property="twitter:description" content="minimal es6 punycode de- and encoder, forked from the &apos;original&apos; "></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/hiherto-elements/es-next-modules"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-punycode">punycode</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">punycode/punycode.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = &apos;-&apos;; // &apos;\x2D&apos;

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	&apos;overflow&apos;: &apos;Overflow: input needs wider integers to process&apos;,
	&apos;not-basic&apos;: &apos;Illegal input &gt;= 0x80 (not a basic code point)&apos;,
	&apos;invalid-input&apos;: &apos;Invalid input&apos;
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split(&apos;@&apos;);
	let result = &apos;&apos;;
	if (parts.length &gt; 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = `${parts[0]}@`;
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, &apos;\x2E&apos;);
	const labels = string.split(&apos;.&apos;);
	const encoded = map(labels, fn).join(&apos;.&apos;);
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter &lt; length) {
		const value = string.charCodeAt(counter++);
		if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
			// It&apos;s a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra &amp; 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
			} else {
				// It&apos;s an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array =&gt; String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = codePoint =&gt; {
	if (codePoint - 0x30 &lt; 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 &lt; 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 &lt; 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = (digit, flag) =&gt; //  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = (delta, numPoints, firstTime) =&gt; {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = input =&gt; {
	// Don&apos;t use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic &lt; 0) {
		basic = 0;
	}

	for (let j = 0; j &lt; basic; ++j) {
		// if it&apos;s not a basic code point
		if (input.charCodeAt(j) &gt;= 0x80) {
			error(&apos;not-basic&apos;);
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index &gt;= inputLength) {
				error(&apos;invalid-input&apos;);
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {
				error(&apos;overflow&apos;);
			}

			i += digit * w;
			const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);

			if (digit &lt; t) {
				break;
			}

			const baseMinusT = base - t;
			if (w &gt; floor(maxInt / baseMinusT)) {
				error(&apos;overflow&apos;);
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we&apos;ll fix that now:
		if (floor(i / out) &gt; maxInt - n) {
			error(&apos;overflow&apos;);
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = input =&gt; {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue &lt; 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it&apos;s empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount &lt; inputLength) {

		// All non-basic code points &lt; n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder&apos;s &lt;n,i&gt; state to &lt;m,0&gt;,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {
			error(&apos;overflow&apos;);
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {
				error(&apos;overflow&apos;);
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);
					if (q &lt; t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join(&apos;&apos;);
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn&apos;t matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = input =&gt; mapDomain(input, string =&gt; regexPunycode.test(string)
    ? decode(string.slice(4).toLowerCase())
    : string);

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn&apos;t matter if you call it with a domain that&apos;s already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = input =&gt; mapDomain(input, string =&gt; regexNonASCII.test(string)
    ? `xn--${encode(string)}`
    : string);

/*--------------------------------------------------------------------------*/

/** Define the public API */
export const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	&apos;version&apos;: &apos;2.1.0&apos;,
	/**
	 * An object of methods to convert from JavaScript&apos;s internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt;
	 * @memberOf punycode
	 * @type Object
	 */
	&apos;ucs2&apos;: {
		&apos;decode&apos;: ucs2decode,
		&apos;encode&apos;: ucs2encode
	},
	&apos;decode&apos;: decode,
	&apos;encode&apos;: encode,
	&apos;toASCII&apos;: toASCII,
	&apos;toUnicode&apos;: toUnicode
};

export default punycode;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
