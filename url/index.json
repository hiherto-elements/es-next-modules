[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "url/Url.js",
    "content": "import { punycode } from './node_modules/@hiherto-elements/punycode/punycode.js';\nimport {util} from './util.js';\nimport querystring from './node_modules/@hiherto-elements/querystring/querystring.js';\nexport {urlParse as parse};\nexport {urlResolve as resolve};\nexport {urlResolveObject as resolveObject};\nexport {urlFormat as format};\n\nexport class Url {\n  constructor() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n  }\n\n  parse(url, parseQueryString, slashesDenoteHost) {\n    if (!util.isString(url)) {\n      throw new TypeError(`Parameter 'url' must be a string, not ${typeof url}`);\n    }\n\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    const queryIndex = url.indexOf('?');\n\n    const splitter =\n        (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#';\n\n    const uSplit = url.split(splitter);\n    const slashRegex = /\\\\/g;\n    uSplit[0] = uSplit[0].replace(slashRegex, '/');\n    url = uSplit.join(splitter);\n\n    let rest = url;\n\n    // trim before proceeding.\n    // This is to support parse stuff like \"  http://foo.com  \\n\"\n    rest = rest.trim();\n\n    if (!slashesDenoteHost && url.split('#').length === 1) {\n      // Try fast path regexp\n      const simplePath = simplePathPattern.exec(rest);\n      if (simplePath) {\n        this.path = rest;\n        this.href = rest;\n        this.pathname = simplePath[1];\n        if (simplePath[2]) {\n          this.search = simplePath[2];\n          if (parseQueryString) {\n            this.query = querystring.parse(this.search.substr(1));\n          } else {\n            this.query = this.search.substr(1);\n          }\n        } else if (parseQueryString) {\n          this.search = '';\n          this.query = {};\n        }\n        return this;\n      }\n    }\n\n    let proto = protocolPattern.exec(rest);\n    let lowerProto;\n    if (proto) {\n      proto = proto[0];\n      lowerProto = proto.toLowerCase();\n      this.protocol = lowerProto;\n      rest = rest.substr(proto.length);\n    }\n\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n    if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n      var slashes = rest.substr(0, 2) === '//';\n      if (slashes && !(proto && hostlessProtocol[proto])) {\n        rest = rest.substr(2);\n        this.slashes = true;\n      }\n    }\n\n    if (!hostlessProtocol[proto] &&\n        (slashes || (proto && !slashedProtocol[proto]))) {\n      // there's a hostname.\n      // the first instance of /, ?, ;, or # ends the host.\n      //\n      // If there is an @ in the hostname, then non-host chars *are* allowed\n      // to the left of the last @ sign, unless some host-ending character\n      // comes *before* the @-sign.\n      // URLs are obnoxious.\n      //\n      // ex:\n      // http://a@b@c/ => user:a@b host:c\n      // http://a@b?@c => user:a host:c path:/?@c\n\n      // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n      // Review our test case against browsers more comprehensively.\n\n      // find the first instance of any hostEndingChars\n      let hostEnd = -1;\n      for (var i = 0; i < hostEndingChars.length; i++) {\n        var hec = rest.indexOf(hostEndingChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n          hostEnd = hec;\n      }\n\n      // at this point, either we have an explicit point where the\n      // auth portion cannot go past, or the last @ char is the decider.\n      let auth;\n\n      let atSign;\n      if (hostEnd === -1) {\n        // atSign can be anywhere.\n        atSign = rest.lastIndexOf('@');\n      } else {\n        // atSign must be in auth portion.\n        // http://a@b/c@d => host:b auth:a path:/c@d\n        atSign = rest.lastIndexOf('@', hostEnd);\n      }\n\n      // Now we have a portion which is definitely the auth.\n      // Pull that off.\n      if (atSign !== -1) {\n        auth = rest.slice(0, atSign);\n        rest = rest.slice(atSign + 1);\n        this.auth = decodeURIComponent(auth);\n      }\n\n      // the host is the remaining to the left of the first non-host char\n      hostEnd = -1;\n      for (var i = 0; i < nonHostChars.length; i++) {\n        var hec = rest.indexOf(nonHostChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n          hostEnd = hec;\n      }\n      // if we still have not hit it, then the entire thing is a host.\n      if (hostEnd === -1)\n        hostEnd = rest.length;\n\n      this.host = rest.slice(0, hostEnd);\n      rest = rest.slice(hostEnd);\n\n      // pull out port.\n      this.parseHost();\n\n      // we've indicated that there is a hostname,\n      // so even if it's empty, it has to be present.\n      this.hostname = this.hostname || '';\n\n      // if hostname begins with [ and ends with ]\n      // assume that it's an IPv6 address.\n      const ipv6Hostname = this.hostname[0] === '[' &&\n          this.hostname[this.hostname.length - 1] === ']';\n\n      // validate a little.\n      if (!ipv6Hostname) {\n        const hostparts = this.hostname.split(/\\./);\n        for (var i = 0, l = hostparts.length; i < l; i++) {\n          const part = hostparts[i];\n          if (!part) continue;\n          if (!part.match(hostnamePartPattern)) {\n            let newpart = '';\n            for (let j = 0, k = part.length; j < k; j++) {\n              if (part.charCodeAt(j) > 127) {\n                // we replace non-ASCII char with a temporary placeholder\n                // we need this to make sure size of hostname is not\n                // broken by replacing non-ASCII by nothing\n                newpart += 'x';\n              } else {\n                newpart += part[j];\n              }\n            }\n            // we test again with ASCII char only\n            if (!newpart.match(hostnamePartPattern)) {\n              const validParts = hostparts.slice(0, i);\n              const notHost = hostparts.slice(i + 1);\n              const bit = part.match(hostnamePartStart);\n              if (bit) {\n                validParts.push(bit[1]);\n                notHost.unshift(bit[2]);\n              }\n              if (notHost.length) {\n                rest = `/${notHost.join('.')}${rest}`;\n              }\n              this.hostname = validParts.join('.');\n              break;\n            }\n          }\n        }\n      }\n\n      if (this.hostname.length > hostnameMaxLen) {\n        this.hostname = '';\n      } else {\n        // hostnames are always lower case.\n        this.hostname = this.hostname.toLowerCase();\n      }\n\n      if (!ipv6Hostname) {\n        // IDNA Support: Returns a punycoded representation of \"domain\".\n        // It only converts parts of the domain name that\n        // have non-ASCII characters, i.e. it doesn't matter if\n        // you call it with a domain that already is ASCII-only.\n        this.hostname = punycode.toASCII(this.hostname);\n      }\n\n      var p = this.port ? `:${this.port}` : '';\n      const h = this.hostname || '';\n      this.host = h + p;\n      this.href += this.host;\n\n      // strip [ and ] from the hostname\n      // the host field still retains them, though\n      if (ipv6Hostname) {\n        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n        if (rest[0] !== '/') {\n          rest = `/${rest}`;\n        }\n      }\n    }\n\n    // now rest is set to the post-host stuff.\n    // chop off any delim chars.\n    if (lowerProto && !unsafeProtocol[lowerProto]) {\n\n      // First, make 100% sure that any \"autoEscape\" chars get\n      // escaped, even if encodeURIComponent doesn't think they\n      // need to be.\n      for (var i = 0, l = autoEscape.length; i < l; i++) {\n        const ae = autoEscape[i];\n        if (!rest.includes(ae))\n          continue;\n        let esc = encodeURIComponent(ae);\n        if (esc === ae) {\n          esc = escape(ae);\n        }\n        rest = rest.split(ae).join(esc);\n      }\n    }\n\n\n    // chop off from the tail first.\n    const hash = rest.indexOf('#');\n    if (hash !== -1) {\n      // got a fragment string.\n      this.hash = rest.substr(hash);\n      rest = rest.slice(0, hash);\n    }\n    const qm = rest.indexOf('?');\n    if (qm !== -1) {\n      this.search = rest.substr(qm);\n      this.query = rest.substr(qm + 1);\n      if (parseQueryString) {\n        this.query = querystring.parse(this.query);\n      }\n      rest = rest.slice(0, qm);\n    } else if (parseQueryString) {\n      // no query string, but parseQueryString still requested\n      this.search = '';\n      this.query = {};\n    }\n    if (rest) this.pathname = rest;\n    if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n      this.pathname = '/';\n    }\n\n    //to support http.request\n    if (this.pathname || this.search) {\n      var p = this.pathname || '';\n      const s = this.search || '';\n      this.path = p + s;\n    }\n\n    // finally, reconstruct the href based on what has been validated.\n    this.href = this.format();\n    return this;\n  }\n\n  format() {\n    let auth = this.auth || '';\n    if (auth) {\n      auth = encodeURIComponent(auth);\n      auth = auth.replace(/%3A/i, ':');\n      auth += '@';\n    }\n\n    let protocol = this.protocol || '';\n    let pathname = this.pathname || '';\n    let hash = this.hash || '';\n    let host = false;\n    let query = '';\n\n    if (this.host) {\n      host = auth + this.host;\n    } else if (this.hostname) {\n      host = auth + (!this.hostname.includes(':') ?\n          this.hostname :\n          '[' + this.hostname + ']');\n      if (this.port) {\n        host += `:${this.port}`;\n      }\n    }\n\n    if (this.query &&\n        util.isObject(this.query) &&\n        Object.keys(this.query).length) {\n      query = querystring.stringify(this.query);\n    }\n\n    let search = this.search || (query && (`?${query}`)) || '';\n\n    if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n    // unless they had them to begin with.\n    if (this.slashes ||\n        (!protocol || slashedProtocol[protocol]) && host !== false) {\n      host = `//${host || ''}`;\n      if (pathname && pathname.charAt(0) !== '/') pathname = `/${pathname}`;\n    } else if (!host) {\n      host = '';\n    }\n\n    if (hash && hash.charAt(0) !== '#') hash = `#${hash}`;\n    if (search && search.charAt(0) !== '?') search = `?${search}`;\n\n    pathname = pathname.replace(/[?#]/g, match => encodeURIComponent(match));\n    search = search.replace('#', '%23');\n\n    return protocol + host + pathname + search + hash;\n  }\n\n  resolve(relative) {\n    return this.resolveObject(urlParse(relative, false, true)).format();\n  }\n\n  resolveObject(relative) {\n    if (util.isString(relative)) {\n      const rel = new Url();\n      rel.parse(relative, false, true);\n      relative = rel;\n    }\n\n    const result = new Url();\n    const tkeys = Object.keys(this);\n\n    for (const tkey of tkeys) {\n      result[tkey] = this[tkey];\n    }\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there's nothing left to do here.\n    if (relative.href === '') {\n      result.href = result.format();\n      return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative.protocol) {\n      // take everything except the protocol from relative\n      const rkeys = Object.keys(relative);\n\n      for (const rkey of rkeys) {\n        if (rkey !== 'protocol')\n          result[rkey] = relative[rkey];\n      }\n\n      //urlParse appends trailing / to urls like http://www.example.com\n      if (slashedProtocol[result.protocol] &&\n          result.hostname && !result.pathname) {\n        result.path = result.pathname = '/';\n      }\n\n      result.href = result.format();\n      return result;\n    }\n\n    if (relative.protocol && relative.protocol !== result.protocol) {\n      // if it's a known url protocol, then changing\n      // the protocol does weird things\n      // first, if it's not file:, then we MUST have a host,\n      // and if there was a path\n      // to begin with, then we MUST have a path.\n      // if it is file:, then the host is dropped,\n      // because that's known to be hostless.\n      // anything else is assumed to be absolute.\n      if (!slashedProtocol[relative.protocol]) {\n        const keys = Object.keys(relative);\n\n        for (const k of keys) {\n          result[k] = relative[k];\n        }\n\n        result.href = result.format();\n        return result;\n      }\n\n      result.protocol = relative.protocol;\n      if (!relative.host && !hostlessProtocol[relative.protocol]) {\n        var relPath = (relative.pathname || '').split('/');\n        while (relPath.length && !(relative.host = relPath.shift()));\n        if (!relative.host) relative.host = '';\n        if (!relative.hostname) relative.hostname = '';\n        if (relPath[0] !== '') relPath.unshift('');\n        if (relPath.length < 2) relPath.unshift('');\n        result.pathname = relPath.join('/');\n      } else {\n        result.pathname = relative.pathname;\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      result.host = relative.host || '';\n      result.auth = relative.auth;\n      result.hostname = relative.hostname || relative.host;\n      result.port = relative.port;\n      // to support http.request\n      if (result.pathname || result.search) {\n        const p = result.pathname || '';\n        const s = result.search || '';\n        result.path = p + s;\n      }\n      result.slashes = result.slashes || relative.slashes;\n      result.href = result.format();\n      return result;\n    }\n\n    const isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');\n\n    const isRelAbs = (\n        relative.host ||\n        relative.pathname && relative.pathname.charAt(0) === '/'\n    );\n\n    let mustEndAbs = (isRelAbs || isSourceAbs ||\n                  (result.host && relative.pathname));\n\n    const removeAllDots = mustEndAbs;\n    let srcPath = result.pathname && result.pathname.split('/') || [];\n    const relPath = relative.pathname && relative.pathname.split('/') || [];\n    const psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n      result.hostname = '';\n      result.port = null;\n      if (result.host) {\n        if (srcPath[0] === '') srcPath[0] = result.host;\n        else srcPath.unshift(result.host);\n      }\n      result.host = '';\n      if (relative.protocol) {\n        relative.hostname = null;\n        relative.port = null;\n        if (relative.host) {\n          if (relPath[0] === '') relPath[0] = relative.host;\n          else relPath.unshift(relative.host);\n        }\n        relative.host = null;\n      }\n      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n    }\n\n    if (isRelAbs) {\n      // it's absolute.\n      result.host = (relative.host || relative.host === '') ?\n                    relative.host : result.host;\n      result.hostname = (relative.hostname || relative.hostname === '') ?\n                        relative.hostname : result.hostname;\n      result.search = relative.search;\n      result.query = relative.query;\n      srcPath = relPath;\n      // fall through to the dot-handling below.\n    } else if (relPath.length) {\n      // it's relative\n      // throw away the existing file, and take the new path instead.\n      if (!srcPath) srcPath = [];\n      srcPath.pop();\n      srcPath = srcPath.concat(relPath);\n      result.search = relative.search;\n      result.query = relative.query;\n    } else if (!util.isNullOrUndefined(relative.search)) {\n      // just pull out the search.\n      // like href='?foo'.\n      // Put this after the other two cases because it simplifies the booleans\n      if (psychotic) {\n        result.hostname = result.host = srcPath.shift();\n        //occationaly the auth can get stuck only in host\n        //this especially happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n        var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                         result.host.split('@') : false;\n        if (authInHost) {\n          result.auth = authInHost.shift();\n          result.host = result.hostname = authInHost.shift();\n        }\n      }\n      result.search = relative.search;\n      result.query = relative.query;\n      //to support http.request\n      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') +\n                      (result.search ? result.search : '');\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    if (!srcPath.length) {\n      // no path at all.  easy.\n      // we've already handled the other stuff above.\n      result.pathname = null;\n      //to support http.request\n      if (result.search) {\n        result.path = `/${result.search}`;\n      } else {\n        result.path = null;\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    let last = srcPath.slice(-1)[0];\n    const hasTrailingSlash = (\n        (result.host || relative.host || srcPath.length > 1) &&\n        (last === '.' || last === '..') || last === '');\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    let up = 0;\n    for (let i = srcPath.length; i >= 0; i--) {\n      last = srcPath[i];\n      if (last === '.') {\n        srcPath.splice(i, 1);\n      } else if (last === '..') {\n        srcPath.splice(i, 1);\n        up++;\n      } else if (up) {\n        srcPath.splice(i, 1);\n        up--;\n      }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n      for (; up--; up) {\n        srcPath.unshift('..');\n      }\n    }\n\n    if (mustEndAbs && srcPath[0] !== '' &&\n        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n      srcPath.unshift('');\n    }\n\n    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n      srcPath.push('');\n    }\n\n    const isAbsolute = srcPath[0] === '' ||\n        (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n    // put the host back\n    if (psychotic) {\n      result.hostname = result.host = isAbsolute ? '' :\n                                      srcPath.length ? srcPath.shift() : '';\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n      srcPath.unshift('');\n    }\n\n    if (!srcPath.length) {\n      result.pathname = null;\n      result.path = null;\n    } else {\n      result.pathname = srcPath.join('/');\n    }\n\n    //to support request.http\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  parseHost() {\n    let host = this.host;\n    let port = portPattern.exec(host);\n    if (port) {\n      port = port[0];\n      if (port !== ':') {\n        this.port = port.substr(1);\n      }\n      host = host.substr(0, host.length - port.length);\n    }\n    if (host) this.hostname = host;\n  }\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i;\n\nvar portPattern = /:[0-9]*$/;\n\nvar // Special case for a simple path URL\nsimplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n\nconst // RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\ndelims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'];\n\nconst // RFC 2396: characters not allowed for various reasons.\nunwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims);\n\nvar // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nautoEscape = ['\\''].concat(unwise);\n\nvar // Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nnonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\n\nvar hostEndingChars = ['/', '?', '#'];\nvar hostnameMaxLen = 255;\nvar hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\nvar hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n\nvar // protocols that can allow \"unsafe\" and \"unwise\" chars.\nunsafeProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n\nvar // protocols that never have a hostname.\nhostlessProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n\nvar // protocols that always contain a // bit.\nslashedProtocol = {\n  'http': true,\n  'https': true,\n  'ftp': true,\n  'gopher': true,\n  'file': true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\n\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  const u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n",
    "static": true,
    "longname": "/home/sebs/projects/opensource/es-next-modules/packages/url/Url.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "Url",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~Url",
    "access": "public",
    "export": true,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": "{Url}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "protocol",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#protocol",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "slashes",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#slashes",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "auth",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#auth",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "host",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#host",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "port",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#port",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "hostname",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#hostname",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "member",
    "name": "hash",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#hash",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "member",
    "name": "search",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#search",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "member",
    "name": "query",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#query",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 12,
    "kind": "member",
    "name": "pathname",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#pathname",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "member",
    "name": "path",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#path",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "member",
    "name": "href",
    "memberof": "url/Url.js~Url",
    "static": false,
    "longname": "url/Url.js~Url#href",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "method",
    "name": "parse",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#parse",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "parseQueryString",
        "types": [
          "*"
        ]
      },
      {
        "name": "slashesDenoteHost",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 46,
    "kind": "method",
    "name": "format",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#format",
    "access": "public",
    "description": null,
    "lineNumber": 290,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 47,
    "kind": "method",
    "name": "resolve",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#resolve",
    "access": "public",
    "description": null,
    "lineNumber": 344,
    "undocument": true,
    "params": [
      {
        "name": "relative",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 48,
    "kind": "method",
    "name": "resolveObject",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#resolveObject",
    "access": "public",
    "description": null,
    "lineNumber": 348,
    "undocument": true,
    "params": [
      {
        "name": "relative",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 49,
    "kind": "method",
    "name": "parseHost",
    "memberof": "url/Url.js~Url",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "url/Url.js~Url#parseHost",
    "access": "public",
    "description": null,
    "lineNumber": 622,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 52,
    "kind": "variable",
    "name": "protocolPattern",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~protocolPattern",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 640,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "variable",
    "name": "portPattern",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~portPattern",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 642,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 54,
    "kind": "variable",
    "name": "simplePathPattern",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~simplePathPattern",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 644,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 55,
    "kind": "variable",
    "name": "delims",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~delims",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 647,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "unwise",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~unwise",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 651,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "autoEscape",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~autoEscape",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 654,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "nonHostChars",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~nonHostChars",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 657,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "hostEndingChars",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~hostEndingChars",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 663,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "hostnameMaxLen",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~hostnameMaxLen",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 664,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "variable",
    "name": "hostnamePartPattern",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~hostnamePartPattern",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 665,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "name": "hostnamePartStart",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~hostnamePartStart",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 666,
    "undocument": true,
    "type": {
      "types": [
        "undefined"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "variable",
    "name": "unsafeProtocol",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~unsafeProtocol",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 668,
    "undocument": true,
    "type": {
      "types": [
        "{\"javascript\": boolean, \"javascript:\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 64,
    "kind": "variable",
    "name": "hostlessProtocol",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~hostlessProtocol",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 674,
    "undocument": true,
    "type": {
      "types": [
        "{\"javascript\": boolean, \"javascript:\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "variable",
    "name": "slashedProtocol",
    "memberof": "url/Url.js",
    "static": true,
    "longname": "url/Url.js~slashedProtocol",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 680,
    "undocument": true,
    "type": {
      "types": [
        "{\"http\": boolean, \"https\": boolean, \"ftp\": boolean, \"gopher\": boolean, \"file\": boolean, \"http:\": boolean, \"https:\": boolean, \"ftp:\": boolean, \"gopher:\": boolean, \"file:\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "urlParse",
    "memberof": "url/Url.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "url/Url.js~urlParse",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 696,
    "undocument": true,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "parseQueryString",
        "types": [
          "*"
        ]
      },
      {
        "name": "slashesDenoteHost",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "urlFormat",
    "memberof": "url/Url.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "url/Url.js~urlFormat",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 705,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "urlResolve",
    "memberof": "url/Url.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "url/Url.js~urlResolve",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 715,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "relative",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "urlResolveObject",
    "memberof": "url/Url.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "url/Url.js~urlResolveObject",
    "access": "public",
    "export": false,
    "importPath": "@hiherto-elements/url/url/Url.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 719,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      },
      {
        "name": "relative",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "url/test/Url.js",
    "content": "import { Assert as assert } from '../node_modules/@hiherto-elements/assert/Assert.js';\nimport { parse } from '../Url.js';\nimport { fixtures as parseTests } from './fixtures.js';\n\nObject.keys(parseTests).forEach(u => {\n\tconst parsed = parse(u);\n\tconst testStrings = parseTests[u];\n\tconst tests = Object.keys(testStrings);\n\ttests.map(test => {\n\t\tassert.equal(parsed[test], testStrings[test], `parsing ${u} checking ${test} expects ${testStrings[test]} but got ${parsed[test]}`)\n\t});\n\n/*\n\t// this is the only one that seems broken after porting punycode, querystring and url\n  '<http://goo.corn/bread> Is a URL!': {\n    'href': '%3Chttp://goo.corn/bread%3E%20Is%20a%20URL!',\n    'pathname': '%3Chttp://goo.corn/bread%3E%20Is%20a%20URL!',\n    'path': '%3Chttp://goo.corn/bread%3E%20Is%20a%20URL!'\n  },\n*/\n\n\n});",
    "static": true,
    "longname": "/home/sebs/projects/opensource/es-next-modules/packages/url/test/Url.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# @hiherto-elements/url\n\nA es6 module fork of [url](https://github.com/defunctzombie/node-url)",
    "longname": "/home/sebs/projects/opensource/es-next-modules/packages/url/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  }
]